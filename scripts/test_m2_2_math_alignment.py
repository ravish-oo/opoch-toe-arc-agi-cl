#!/usr/bin/env python3
"""
Test mathematical correctness of constraints generated by builder.py

Verifies alignment with math kernel spec section 0 and 1.1:
  - B(T)y = 0
  - y ∈ {0,1}^{NC}
  - Σ_c y_{p,c} = 1 ∀p

This doesn't actually solve an LP, but verifies that:
1. Constraint equations are mathematically valid
2. Indices reference valid y-vector positions
3. Coefficient patterns match spec requirements
"""

import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from src.constraints.builder import (
    LinearConstraint,
    ConstraintBuilder,
    add_one_hot_constraints
)
from src.constraints.indexing import y_index, y_index_to_pc


def verify_constraint_equation(lc: LinearConstraint, y_vector: list) -> float:
    """
    Evaluate a constraint equation: sum_i coeffs[i] * y[indices[i]]

    Returns the left-hand side value (should equal lc.rhs for valid solution).
    """
    total = 0.0
    for idx, coeff in zip(lc.indices, lc.coeffs):
        total += coeff * y_vector[idx]
    return total


def test_one_hot_satisfiability():
    """
    Test that one-hot constraints are mathematically satisfiable.

    For a valid y-vector where each pixel has exactly one color,
    all one-hot constraints should be satisfied.
    """
    print("Testing one-hot constraint satisfiability...")

    # Small grid: 2 pixels, 3 colors
    N, C = 2, 3

    # Build one-hot constraints
    builder = ConstraintBuilder()
    add_one_hot_constraints(builder, N, C)

    # Create a valid y-vector: pixel 0 has color 1, pixel 1 has color 2
    # y = [0, 1, 0,  0, 0, 1]
    #      p0:c0-c2  p1:c0-c2
    y_vector = [0.0] * (N * C)
    y_vector[y_index(0, 1, C)] = 1.0  # pixel 0 → color 1
    y_vector[y_index(1, 2, C)] = 1.0  # pixel 1 → color 2

    # Verify all one-hot constraints are satisfied
    for lc in builder.constraints:
        lhs = verify_constraint_equation(lc, y_vector)
        assert abs(lhs - lc.rhs) < 1e-10, \
            f"Constraint not satisfied: {lhs} != {lc.rhs}"

    print(f"  ✓ All {len(builder.constraints)} one-hot constraints satisfied")


def test_tie_constraint_satisfiability():
    """
    Test that tie constraints work correctly.

    If two pixels are tied, they must have the same color in any valid solution.
    """
    print("Testing tie constraint satisfiability...")

    N, C = 3, 4

    # Build constraints: tie pixels 0 and 2
    builder = ConstraintBuilder()
    builder.tie_pixel_colors(0, 2, C)

    # Create y-vector where pixels 0 and 2 both have color 3
    y_vector = [0.0] * (N * C)
    y_vector[y_index(0, 3, C)] = 1.0  # pixel 0 → color 3
    y_vector[y_index(1, 1, C)] = 1.0  # pixel 1 → color 1 (different)
    y_vector[y_index(2, 3, C)] = 1.0  # pixel 2 → color 3 (same as pixel 0)

    # All tie constraints should be satisfied
    for lc in builder.constraints:
        lhs = verify_constraint_equation(lc, y_vector)
        assert abs(lhs - lc.rhs) < 1e-10, \
            f"Tie constraint not satisfied: {lhs} != {lc.rhs}"

    print(f"  ✓ All {len(builder.constraints)} tie constraints satisfied")


def test_tie_constraint_violation():
    """
    Test that tie constraints detect violations.

    If two pixels have different colors, tie constraints should NOT be satisfied.
    """
    print("Testing tie constraint violation detection...")

    N, C = 3, 4

    # Build constraints: tie pixels 0 and 2
    builder = ConstraintBuilder()
    builder.tie_pixel_colors(0, 2, C)

    # Create INVALID y-vector where pixels 0 and 2 have DIFFERENT colors
    y_vector = [0.0] * (N * C)
    y_vector[y_index(0, 1, C)] = 1.0  # pixel 0 → color 1
    y_vector[y_index(1, 2, C)] = 1.0  # pixel 1 → color 2
    y_vector[y_index(2, 3, C)] = 1.0  # pixel 2 → color 3 (DIFFERENT from pixel 0)

    # At least one tie constraint should be violated
    violations = 0
    for lc in builder.constraints:
        lhs = verify_constraint_equation(lc, y_vector)
        if abs(lhs - lc.rhs) > 1e-10:
            violations += 1

    assert violations > 0, "Expected constraint violations when pixels have different colors"

    print(f"  ✓ Detected {violations} violations (expected for mismatched colors)")


def test_fix_constraint_satisfiability():
    """
    Test that fix_pixel_color constraints work correctly.
    """
    print("Testing fix constraint satisfiability...")

    N, C = 4, 5

    # Fix pixel 2 to color 3
    builder = ConstraintBuilder()
    builder.fix_pixel_color(2, 3, C)

    # Create y-vector with pixel 2 having color 3
    y_vector = [0.0] * (N * C)
    y_vector[y_index(2, 3, C)] = 1.0

    # Fix constraint should be satisfied
    lc = builder.constraints[0]
    lhs = verify_constraint_equation(lc, y_vector)
    assert abs(lhs - lc.rhs) < 1e-10, \
        f"Fix constraint not satisfied: {lhs} != {lc.rhs}"

    print("  ✓ Fix constraint satisfied when pixel has correct color")


def test_forbid_constraint_satisfiability():
    """
    Test that forbid_pixel_color constraints work correctly.
    """
    print("Testing forbid constraint satisfiability...")

    N, C = 4, 5

    # Forbid pixel 1 from being color 2
    builder = ConstraintBuilder()
    builder.forbid_pixel_color(1, 2, C)

    # Create y-vector with pixel 1 having color 4 (not 2)
    y_vector = [0.0] * (N * C)
    y_vector[y_index(1, 4, C)] = 1.0

    # Forbid constraint should be satisfied (y[1,2] = 0)
    lc = builder.constraints[0]
    lhs = verify_constraint_equation(lc, y_vector)
    assert abs(lhs - lc.rhs) < 1e-10, \
        f"Forbid constraint not satisfied: {lhs} != {lc.rhs}"

    print("  ✓ Forbid constraint satisfied when pixel has different color")


def test_combined_system_satisfiability():
    """
    Test that a combination of constraint types can be satisfied.

    This simulates what a real schema builder would create.
    """
    print("Testing combined constraint system...")

    # Grid: H=2, W=2, C=3
    # 4 pixels, 3 colors, y-vector size = 12
    N, C = 4, 3

    builder = ConstraintBuilder()

    # Add one-hot constraints (every pixel must have exactly one color)
    add_one_hot_constraints(builder, N, C)

    # Tie pixels 0 and 3 (diagonal corners same color)
    builder.tie_pixel_colors(0, 3, C)

    # Fix pixel 1 to color 2
    builder.fix_pixel_color(1, 2, C)

    # Forbid pixel 2 from being color 0
    builder.forbid_pixel_color(2, 0, C)

    # Create a valid y-vector satisfying all constraints:
    # pixel 0: color 1 (tied with pixel 3)
    # pixel 1: color 2 (fixed)
    # pixel 2: color 1 (not color 0, forbidden)
    # pixel 3: color 1 (tied with pixel 0)
    y_vector = [0.0] * (N * C)
    y_vector[y_index(0, 1, C)] = 1.0
    y_vector[y_index(1, 2, C)] = 1.0
    y_vector[y_index(2, 1, C)] = 1.0
    y_vector[y_index(3, 1, C)] = 1.0

    # Verify ALL constraints are satisfied
    for i, lc in enumerate(builder.constraints):
        lhs = verify_constraint_equation(lc, y_vector)
        assert abs(lhs - lc.rhs) < 1e-10, \
            f"Constraint {i} not satisfied: {lhs} != {lc.rhs}"

    print(f"  ✓ All {len(builder.constraints)} constraints satisfied in combined system")


def test_coefficient_patterns():
    """
    Verify coefficient patterns match math kernel spec requirements.

    For totally unimodular (TU) matrices, coefficients should be {-1, 0, 1}.
    Our implementation uses floats but should only generate these values.
    """
    print("Testing coefficient patterns for TU property...")

    N, C = 5, 10
    builder = ConstraintBuilder()

    # Add various constraint types
    add_one_hot_constraints(builder, N, C)
    builder.tie_pixel_colors(0, 3, C)
    builder.fix_pixel_color(2, 5, C)
    builder.forbid_pixel_color(4, 7, C)

    # Check all coefficients are in {-1.0, 1.0}
    # (0.0 wouldn't appear in our sparse representation)
    valid_coeffs = {-1.0, 1.0}

    for lc in builder.constraints:
        for coeff in lc.coeffs:
            assert coeff in valid_coeffs, \
                f"Invalid coefficient {coeff} (expected -1.0 or 1.0)"

    print("  ✓ All coefficients in {-1.0, 1.0} (TU property)")


def test_index_coverage():
    """
    Verify that constraints reference valid y-vector indices.
    """
    print("Testing index coverage and validity...")

    N, C = 10, 10
    max_idx = N * C - 1

    builder = ConstraintBuilder()
    add_one_hot_constraints(builder, N, C)

    # Collect all referenced indices
    referenced_indices = set()
    for lc in builder.constraints:
        for idx in lc.indices:
            # Verify index is in valid range
            assert 0 <= idx <= max_idx, \
                f"Index {idx} out of range [0, {max_idx}]"
            referenced_indices.add(idx)

    # One-hot constraints should reference all indices at least once
    # (each pixel-color pair appears in exactly one one-hot constraint)
    assert len(referenced_indices) == N * C, \
        f"Expected all {N*C} indices referenced, got {len(referenced_indices)}"

    print(f"  ✓ All {N*C} y-vector indices referenced exactly once")


def test_rhs_values():
    """
    Verify RHS values are appropriate for constraint types.
    """
    print("Testing RHS value patterns...")

    N, C = 5, 10
    builder = ConstraintBuilder()

    # One-hot: rhs = 1.0
    add_one_hot_constraints(builder, N, C)
    for i in range(N):
        assert builder.constraints[i].rhs == 1.0

    # Tie: rhs = 0.0
    start_tie = len(builder.constraints)
    builder.tie_pixel_colors(0, 1, C)
    for i in range(start_tie, len(builder.constraints)):
        assert builder.constraints[i].rhs == 0.0

    # Fix: rhs = 1.0
    start_fix = len(builder.constraints)
    builder.fix_pixel_color(2, 3, C)
    assert builder.constraints[start_fix].rhs == 1.0

    # Forbid: rhs = 0.0
    start_forbid = len(builder.constraints)
    builder.forbid_pixel_color(3, 4, C)
    assert builder.constraints[start_forbid].rhs == 0.0

    print("  ✓ All RHS values correct for constraint types")


def main():
    print("=" * 60)
    print("WO-M2.2 Mathematical Alignment Test")
    print("=" * 60)
    print()

    try:
        # Satisfiability tests
        test_one_hot_satisfiability()
        test_tie_constraint_satisfiability()
        test_tie_constraint_violation()
        test_fix_constraint_satisfiability()
        test_forbid_constraint_satisfiability()
        test_combined_system_satisfiability()

        # Mathematical property tests
        test_coefficient_patterns()
        test_index_coverage()
        test_rhs_values()

        print()
        print("=" * 60)
        print("✅ ALL MATHEMATICAL ALIGNMENT TESTS PASSED")
        print("=" * 60)
        return 0

    except Exception as e:
        print()
        print("=" * 60)
        print(f"❌ TEST FAILED: {e}")
        print("=" * 60)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
